<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ytdriver.YTDriver API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ytdriver.YTDriver</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from selenium.webdriver import Chrome, ChromeOptions, Firefox, FirefoxOptions
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.by import By
from selenium.common.exceptions import WebDriverException
from time import sleep
from .helpers import Video, VideoUnavailableException, time2seconds
from pyvirtualdisplay import Display
import os

class YTDriver:

    def __init__(self, browser=&#39;chrome&#39;, profile_dir=None, use_virtual_display=False, headless=False, verbose=False):
        &#34;&#34;&#34;
        Initializes the webdriver and virtual display

        ### Arguments:
        - `browser`: Specify `chrome` or `firefox` to launch the corresponding webdriver.
        - `profile_dir`: Specify a directory to save the browser profile so it can be loaded later. Set to `None` to not save the profile.
        - `use_virtual_display`: Set to `True` to launch a virtual display using `pyvirtualdisplay`.
        - `headless`: Set to `True` to run the browser in headless mode.
        - `verbose`: Set to `True` to enable logging messages.
        &#34;&#34;&#34;

        self.verbose = verbose

        if use_virtual_display:
            self.__log(&#34;Starting virtual display&#34;)
            display = Display(size=(1920,1080))
            display.start()

        if browser == &#39;chrome&#39;:
            self.driver = self.__init_chrome(profile_dir, headless)
        elif browser == &#39;firefox&#39;:
            self.driver = self.__init_firefox(profile_dir, headless)
        else:
            raise Exception(&#34;Invalid browser&#34;, browser)

        self.driver.set_page_load_timeout(30)

    def close(self):
        &#34;&#34;&#34;
        Close the underlying webdriver.
        &#34;&#34;&#34;
        self.driver.close()

    def get_homepage(self, scroll_times=0):
        &#34;&#34;&#34;
        Collect videos from the YouTube homepage.

        ### Arguments:
        - `scroll_times`: Number of times to scroll the homepage.

        ### Returns:
        - List of videos of type `ytdriver.helpers.Video`.

        &#34;&#34;&#34;
        # try to find the youtube icon
        try:
            self.__log(&#39;Clicking homepage icon&#39;)
            self.driver.find_element(By.ID, &#39;logo-icon&#39;).click()
        except:
            self.__log(&#39;Getting homepage via URL&#39;)
            self.driver.get(&#39;https://www.youtube.com&#39;)

        # wait for page to load
        sleep(2)

        # scroll page to load more results
        for _ in range(scroll_times):
            self.driver.find_element(By.TAG_NAME, &#39;body&#39;).send_keys(Keys.PAGE_DOWN)
            sleep(0.2)
            

        # collect video-like tags from homepage
        videos = self.driver.find_elements(By.XPATH, &#39;//div[@id=&#34;contents&#34;]/ytd-rich-item-renderer&#39;)

        # identify actual videos from tags
        homepage = []
        for video in videos:
            a = video.find_elements(By.TAG_NAME, &#39;a&#39;)[0]
            href = a.get_attribute(&#39;href&#39;)
            if href is not None and href.startswith(&#39;https://www.youtube.com/watch?&#39;):
                homepage.append(Video(a, href))

        return homepage

    def get_recommendations(self, topn=5):

        &#34;&#34;&#34;
        Collect up-next recommendations for the currently playing video.

        ### Arguments:
        - `topn`: Number of recommendations to return.

        ### Returns:
        - List of videos of type `ytdriver.helpers.Video`.
        
        &#34;&#34;&#34;
        # wait for page to load
        sleep(2)

        # wait for recommendations
        elems = WebDriverWait(self.driver, 30).until(
            EC.presence_of_all_elements_located((By.TAG_NAME, &#39;ytd-compact-video-renderer&#39;))
        )

        # recommended videos array
        return [Video(elem, elem.find_elements(By.TAG_NAME, &#39;a&#39;)[0].get_attribute(&#39;href&#39;)) for elem in elems[:topn]]

    def search_videos(self, query, scroll_times=0):
        &#34;&#34;&#34;
        Search for videos.

        ### Arguments:
        - `query` (`str`): Search query.

        ### Returns:
        - List of videos of type `ytdriver.helpers.Video`.
        
        &#34;&#34;&#34;

        # load video search results
        self.driver.get(&#39;https://www.youtube.com/results?search_query=%s&#39; % query)

        # wait for page to load
        sleep(2)

        # scroll page to load more results
        for _ in range(scroll_times):
            self.driver.find_element(By.TAG_NAME, &#39;body&#39;).send_keys(Keys.PAGE_DOWN)
            sleep(0.2)

        # collect video-like tags from homepage
        videos = self.driver.find_elements(By.XPATH, &#39;//div[@id=&#34;contents&#34;]/ytd-video-renderer&#39;)
        
        # identify actual videos from tags
        results = []
        for video in videos:
            a = video.find_elements(By.TAG_NAME, &#39;a&#39;)[0]
            href = a.get_attribute(&#39;href&#39;)
            if href is not None and href.startswith(&#39;https://www.youtube.com/watch?&#39;):
                results.append(Video(a, href))
        return results


    def play(self, video, duration=5):
        &#34;&#34;&#34;
        Play a video for a set duration. Returns when that duration passes.

        ### Arguments:
        - `video` (`str`|`ytdriver.helpers.Video`): Video object or URL to play.
        - `duration` (`int`): How long to play the video.
        
        &#34;&#34;&#34;
        try:
            self.__click_video(video)
            self.__check_video_availability()
            self.__click_play_button()
            self.__handle_ads()
            self.__clear_prompts()
            sleep(duration)
        except WebDriverException as e:
            self.__log(e)

    def save_screenshot(self, filename):
        &#34;&#34;&#34;
        Save a screenshot of the current browser window.

        ### Arguments:
        - `filename`: Filename to save image as.
        &#34;&#34;&#34;
        return self.driver.save_screenshot(filename)

    ## Helpers
    def __log(self, message):
        if self.verbose:
            print(message)

    def __click_video(self, video):
        if type(video) == Video:
            try:
                # try to click the element using selenium
                self.__log(&#34;Clicking element via Selenium...&#34;)
                video.elem.click()
                return
            except Exception as e:
                try:
                    # try to click the element using javascript
                    self.__log(&#34;Failed. Clicking via Javascript...&#34;)
                    self.driver.execute_script(&#39;arguments[0].click()&#39;, video.elem)
                except:
                    # js click failed, just open the video url
                    self.__log(&#34;Failed. Loading video URL...&#34;)
                    self.driver.get(video.url)
        elif type(video) == str:
            self.driver.get(video)
        else:
            raise ValueError(&#39;Unsupported video parameter!&#39;)

    def __check_video_availability(self):
        try:
            WebDriverWait(self.driver, 5).until(
                EC.presence_of_element_located((By.XPATH, &#39;//*[@id=&#34;container&#34;]/h1&#39;))
            )
        except WebDriverException:
            raise VideoUnavailableException()

    def __click_play_button(self):
        try:
            playBtn = self.driver.find_elements(By.CLASS_NAME, &#39;ytp-play-button&#39;)
            if &#39;Play&#39; in playBtn[0].get_attribute(&#39;title&#39;):
                playBtn[0].click()
        except:
            pass

    def __handle_ads(self):
        # handle multiple ads
        while True:
            sleep(1)

            # check if ad is being shown
            preview = self.driver.find_elements(By.CLASS_NAME, &#39;ytp-ad-preview-container&#39;)
            if len(preview) == 0:
                self.__log(&#39;Ad not detected&#39;)
                # ad is not shown, return
                return

            self.__log(&#39;Ad detected&#39;)
            
            sleep(1)
            preview = preview[0]
            # an ad is being shown
            # grab preview text to determine ad type
            text = preview.text.replace(&#39;\n&#39;, &#39; &#39;)
            wait = 0
            if &#39;after ad&#39; in text:
                # unskippable ad, grab ad length
                length = self.driver.find_elements(By.CLASS_NAME, &#39;ytp-ad-duration-remaining&#39;)[0].text
                wait = time2seconds(length)
                self.__log(&#39;Unskippable ad. Waiting %d seconds...&#39; % wait)
            elif &#39;begin in&#39; in text or &#39;end in&#39; in text:
                # short ad
                wait = int(text.split()[-1])
                self.__log(&#39;Short ad. Waiting for %d seconds...&#39; % wait)
            else:
                # skippable ad, grab time before skippable
                wait = int(text)
                self.__log(&#39;Skippable ad. Skipping after %d seconds...&#39; % wait)

            # wait for ad to finish
            sleep(wait)

            # click skip button if available
            skip = self.driver.find_elements(By.CLASS_NAME, &#39;ytp-ad-skip-button-container&#39;)
            if len(skip) &gt; 0:
                skip[0].click()

    def __clear_prompts(self):
        try:
            sleep(1)
            self.driver.find_element(By.XPATH, &#39;/html/body/ytd-app/ytd-popup-container/tp-yt-iron-dropdown/div/yt-tooltip-renderer/div[2]/div[1]/yt-button-renderer/a/tp-yt-paper-button/yt-formatted-string&#39;).click()
        except:
            pass
    
    def __init_chrome(self, profile_dir, headless):
        options = ChromeOptions()
        options.add_argument(&#39;--no-sandbox&#39;)
        options.add_argument(&#39;--window-size=1920,1080&#39;)

        if profile_dir is not None:
            options.add_argument(&#39;--user-data-dir=%s&#39; % profile_dir)
        if headless:
            options.add_argument(&#39;--headless&#39;)

        return Chrome(options=options)

    def __init_firefox(self, profile_dir, headless):
        options = FirefoxOptions()
        options.add_argument(&#39;--window-size=1920,1080&#39;)
        if profile_dir is not None:
            pass
        if headless:
            options.add_argument(&#39;--headless&#39;)

        service = Service(log_path=os.path.devnull)
        return Firefox(options=options, service=service)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ytdriver.YTDriver.YTDriver"><code class="flex name class">
<span>class <span class="ident">YTDriver</span></span>
<span>(</span><span>browser='chrome', profile_dir=None, use_virtual_display=False, headless=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the webdriver and virtual display</p>
<h3 id="arguments">Arguments:</h3>
<ul>
<li><code>browser</code>: Specify <code>chrome</code> or <code>firefox</code> to launch the corresponding webdriver.</li>
<li><code>profile_dir</code>: Specify a directory to save the browser profile so it can be loaded later. Set to <code>None</code> to not save the profile.</li>
<li><code>use_virtual_display</code>: Set to <code>True</code> to launch a virtual display using <code>pyvirtualdisplay</code>.</li>
<li><code>headless</code>: Set to <code>True</code> to run the browser in headless mode.</li>
<li><code>verbose</code>: Set to <code>True</code> to enable logging messages.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class YTDriver:

    def __init__(self, browser=&#39;chrome&#39;, profile_dir=None, use_virtual_display=False, headless=False, verbose=False):
        &#34;&#34;&#34;
        Initializes the webdriver and virtual display

        ### Arguments:
        - `browser`: Specify `chrome` or `firefox` to launch the corresponding webdriver.
        - `profile_dir`: Specify a directory to save the browser profile so it can be loaded later. Set to `None` to not save the profile.
        - `use_virtual_display`: Set to `True` to launch a virtual display using `pyvirtualdisplay`.
        - `headless`: Set to `True` to run the browser in headless mode.
        - `verbose`: Set to `True` to enable logging messages.
        &#34;&#34;&#34;

        self.verbose = verbose

        if use_virtual_display:
            self.__log(&#34;Starting virtual display&#34;)
            display = Display(size=(1920,1080))
            display.start()

        if browser == &#39;chrome&#39;:
            self.driver = self.__init_chrome(profile_dir, headless)
        elif browser == &#39;firefox&#39;:
            self.driver = self.__init_firefox(profile_dir, headless)
        else:
            raise Exception(&#34;Invalid browser&#34;, browser)

        self.driver.set_page_load_timeout(30)

    def close(self):
        &#34;&#34;&#34;
        Close the underlying webdriver.
        &#34;&#34;&#34;
        self.driver.close()

    def get_homepage(self, scroll_times=0):
        &#34;&#34;&#34;
        Collect videos from the YouTube homepage.

        ### Arguments:
        - `scroll_times`: Number of times to scroll the homepage.

        ### Returns:
        - List of videos of type `ytdriver.helpers.Video`.

        &#34;&#34;&#34;
        # try to find the youtube icon
        try:
            self.__log(&#39;Clicking homepage icon&#39;)
            self.driver.find_element(By.ID, &#39;logo-icon&#39;).click()
        except:
            self.__log(&#39;Getting homepage via URL&#39;)
            self.driver.get(&#39;https://www.youtube.com&#39;)

        # wait for page to load
        sleep(2)

        # scroll page to load more results
        for _ in range(scroll_times):
            self.driver.find_element(By.TAG_NAME, &#39;body&#39;).send_keys(Keys.PAGE_DOWN)
            sleep(0.2)
            

        # collect video-like tags from homepage
        videos = self.driver.find_elements(By.XPATH, &#39;//div[@id=&#34;contents&#34;]/ytd-rich-item-renderer&#39;)

        # identify actual videos from tags
        homepage = []
        for video in videos:
            a = video.find_elements(By.TAG_NAME, &#39;a&#39;)[0]
            href = a.get_attribute(&#39;href&#39;)
            if href is not None and href.startswith(&#39;https://www.youtube.com/watch?&#39;):
                homepage.append(Video(a, href))

        return homepage

    def get_recommendations(self, topn=5):

        &#34;&#34;&#34;
        Collect up-next recommendations for the currently playing video.

        ### Arguments:
        - `topn`: Number of recommendations to return.

        ### Returns:
        - List of videos of type `ytdriver.helpers.Video`.
        
        &#34;&#34;&#34;
        # wait for page to load
        sleep(2)

        # wait for recommendations
        elems = WebDriverWait(self.driver, 30).until(
            EC.presence_of_all_elements_located((By.TAG_NAME, &#39;ytd-compact-video-renderer&#39;))
        )

        # recommended videos array
        return [Video(elem, elem.find_elements(By.TAG_NAME, &#39;a&#39;)[0].get_attribute(&#39;href&#39;)) for elem in elems[:topn]]

    def search_videos(self, query, scroll_times=0):
        &#34;&#34;&#34;
        Search for videos.

        ### Arguments:
        - `query` (`str`): Search query.

        ### Returns:
        - List of videos of type `ytdriver.helpers.Video`.
        
        &#34;&#34;&#34;

        # load video search results
        self.driver.get(&#39;https://www.youtube.com/results?search_query=%s&#39; % query)

        # wait for page to load
        sleep(2)

        # scroll page to load more results
        for _ in range(scroll_times):
            self.driver.find_element(By.TAG_NAME, &#39;body&#39;).send_keys(Keys.PAGE_DOWN)
            sleep(0.2)

        # collect video-like tags from homepage
        videos = self.driver.find_elements(By.XPATH, &#39;//div[@id=&#34;contents&#34;]/ytd-video-renderer&#39;)
        
        # identify actual videos from tags
        results = []
        for video in videos:
            a = video.find_elements(By.TAG_NAME, &#39;a&#39;)[0]
            href = a.get_attribute(&#39;href&#39;)
            if href is not None and href.startswith(&#39;https://www.youtube.com/watch?&#39;):
                results.append(Video(a, href))
        return results


    def play(self, video, duration=5):
        &#34;&#34;&#34;
        Play a video for a set duration. Returns when that duration passes.

        ### Arguments:
        - `video` (`str`|`ytdriver.helpers.Video`): Video object or URL to play.
        - `duration` (`int`): How long to play the video.
        
        &#34;&#34;&#34;
        try:
            self.__click_video(video)
            self.__check_video_availability()
            self.__click_play_button()
            self.__handle_ads()
            self.__clear_prompts()
            sleep(duration)
        except WebDriverException as e:
            self.__log(e)

    def save_screenshot(self, filename):
        &#34;&#34;&#34;
        Save a screenshot of the current browser window.

        ### Arguments:
        - `filename`: Filename to save image as.
        &#34;&#34;&#34;
        return self.driver.save_screenshot(filename)

    ## Helpers
    def __log(self, message):
        if self.verbose:
            print(message)

    def __click_video(self, video):
        if type(video) == Video:
            try:
                # try to click the element using selenium
                self.__log(&#34;Clicking element via Selenium...&#34;)
                video.elem.click()
                return
            except Exception as e:
                try:
                    # try to click the element using javascript
                    self.__log(&#34;Failed. Clicking via Javascript...&#34;)
                    self.driver.execute_script(&#39;arguments[0].click()&#39;, video.elem)
                except:
                    # js click failed, just open the video url
                    self.__log(&#34;Failed. Loading video URL...&#34;)
                    self.driver.get(video.url)
        elif type(video) == str:
            self.driver.get(video)
        else:
            raise ValueError(&#39;Unsupported video parameter!&#39;)

    def __check_video_availability(self):
        try:
            WebDriverWait(self.driver, 5).until(
                EC.presence_of_element_located((By.XPATH, &#39;//*[@id=&#34;container&#34;]/h1&#39;))
            )
        except WebDriverException:
            raise VideoUnavailableException()

    def __click_play_button(self):
        try:
            playBtn = self.driver.find_elements(By.CLASS_NAME, &#39;ytp-play-button&#39;)
            if &#39;Play&#39; in playBtn[0].get_attribute(&#39;title&#39;):
                playBtn[0].click()
        except:
            pass

    def __handle_ads(self):
        # handle multiple ads
        while True:
            sleep(1)

            # check if ad is being shown
            preview = self.driver.find_elements(By.CLASS_NAME, &#39;ytp-ad-preview-container&#39;)
            if len(preview) == 0:
                self.__log(&#39;Ad not detected&#39;)
                # ad is not shown, return
                return

            self.__log(&#39;Ad detected&#39;)
            
            sleep(1)
            preview = preview[0]
            # an ad is being shown
            # grab preview text to determine ad type
            text = preview.text.replace(&#39;\n&#39;, &#39; &#39;)
            wait = 0
            if &#39;after ad&#39; in text:
                # unskippable ad, grab ad length
                length = self.driver.find_elements(By.CLASS_NAME, &#39;ytp-ad-duration-remaining&#39;)[0].text
                wait = time2seconds(length)
                self.__log(&#39;Unskippable ad. Waiting %d seconds...&#39; % wait)
            elif &#39;begin in&#39; in text or &#39;end in&#39; in text:
                # short ad
                wait = int(text.split()[-1])
                self.__log(&#39;Short ad. Waiting for %d seconds...&#39; % wait)
            else:
                # skippable ad, grab time before skippable
                wait = int(text)
                self.__log(&#39;Skippable ad. Skipping after %d seconds...&#39; % wait)

            # wait for ad to finish
            sleep(wait)

            # click skip button if available
            skip = self.driver.find_elements(By.CLASS_NAME, &#39;ytp-ad-skip-button-container&#39;)
            if len(skip) &gt; 0:
                skip[0].click()

    def __clear_prompts(self):
        try:
            sleep(1)
            self.driver.find_element(By.XPATH, &#39;/html/body/ytd-app/ytd-popup-container/tp-yt-iron-dropdown/div/yt-tooltip-renderer/div[2]/div[1]/yt-button-renderer/a/tp-yt-paper-button/yt-formatted-string&#39;).click()
        except:
            pass
    
    def __init_chrome(self, profile_dir, headless):
        options = ChromeOptions()
        options.add_argument(&#39;--no-sandbox&#39;)
        options.add_argument(&#39;--window-size=1920,1080&#39;)

        if profile_dir is not None:
            options.add_argument(&#39;--user-data-dir=%s&#39; % profile_dir)
        if headless:
            options.add_argument(&#39;--headless&#39;)

        return Chrome(options=options)

    def __init_firefox(self, profile_dir, headless):
        options = FirefoxOptions()
        options.add_argument(&#39;--window-size=1920,1080&#39;)
        if profile_dir is not None:
            pass
        if headless:
            options.add_argument(&#39;--headless&#39;)

        service = Service(log_path=os.path.devnull)
        return Firefox(options=options, service=service)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ytdriver.YTDriver.YTDriver.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the underlying webdriver.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    Close the underlying webdriver.
    &#34;&#34;&#34;
    self.driver.close()</code></pre>
</details>
</dd>
<dt id="ytdriver.YTDriver.YTDriver.get_homepage"><code class="name flex">
<span>def <span class="ident">get_homepage</span></span>(<span>self, scroll_times=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Collect videos from the YouTube homepage.</p>
<h3 id="arguments">Arguments:</h3>
<ul>
<li><code>scroll_times</code>: Number of times to scroll the homepage.</li>
</ul>
<h3 id="returns">Returns:</h3>
<ul>
<li>List of videos of type <code><a title="ytdriver.helpers.Video" href="helpers.html#ytdriver.helpers.Video">Video</a></code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_homepage(self, scroll_times=0):
    &#34;&#34;&#34;
    Collect videos from the YouTube homepage.

    ### Arguments:
    - `scroll_times`: Number of times to scroll the homepage.

    ### Returns:
    - List of videos of type `ytdriver.helpers.Video`.

    &#34;&#34;&#34;
    # try to find the youtube icon
    try:
        self.__log(&#39;Clicking homepage icon&#39;)
        self.driver.find_element(By.ID, &#39;logo-icon&#39;).click()
    except:
        self.__log(&#39;Getting homepage via URL&#39;)
        self.driver.get(&#39;https://www.youtube.com&#39;)

    # wait for page to load
    sleep(2)

    # scroll page to load more results
    for _ in range(scroll_times):
        self.driver.find_element(By.TAG_NAME, &#39;body&#39;).send_keys(Keys.PAGE_DOWN)
        sleep(0.2)
        

    # collect video-like tags from homepage
    videos = self.driver.find_elements(By.XPATH, &#39;//div[@id=&#34;contents&#34;]/ytd-rich-item-renderer&#39;)

    # identify actual videos from tags
    homepage = []
    for video in videos:
        a = video.find_elements(By.TAG_NAME, &#39;a&#39;)[0]
        href = a.get_attribute(&#39;href&#39;)
        if href is not None and href.startswith(&#39;https://www.youtube.com/watch?&#39;):
            homepage.append(Video(a, href))

    return homepage</code></pre>
</details>
</dd>
<dt id="ytdriver.YTDriver.YTDriver.get_recommendations"><code class="name flex">
<span>def <span class="ident">get_recommendations</span></span>(<span>self, topn=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Collect up-next recommendations for the currently playing video.</p>
<h3 id="arguments">Arguments:</h3>
<ul>
<li><code>topn</code>: Number of recommendations to return.</li>
</ul>
<h3 id="returns">Returns:</h3>
<ul>
<li>List of videos of type <code><a title="ytdriver.helpers.Video" href="helpers.html#ytdriver.helpers.Video">Video</a></code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_recommendations(self, topn=5):

    &#34;&#34;&#34;
    Collect up-next recommendations for the currently playing video.

    ### Arguments:
    - `topn`: Number of recommendations to return.

    ### Returns:
    - List of videos of type `ytdriver.helpers.Video`.
    
    &#34;&#34;&#34;
    # wait for page to load
    sleep(2)

    # wait for recommendations
    elems = WebDriverWait(self.driver, 30).until(
        EC.presence_of_all_elements_located((By.TAG_NAME, &#39;ytd-compact-video-renderer&#39;))
    )

    # recommended videos array
    return [Video(elem, elem.find_elements(By.TAG_NAME, &#39;a&#39;)[0].get_attribute(&#39;href&#39;)) for elem in elems[:topn]]</code></pre>
</details>
</dd>
<dt id="ytdriver.YTDriver.YTDriver.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self, video, duration=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Play a video for a set duration. Returns when that duration passes.</p>
<h3 id="arguments">Arguments:</h3>
<ul>
<li><code>video</code> (<code>str</code>|<code><a title="ytdriver.helpers.Video" href="helpers.html#ytdriver.helpers.Video">Video</a></code>): Video object or URL to play.</li>
<li><code>duration</code> (<code>int</code>): How long to play the video.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play(self, video, duration=5):
    &#34;&#34;&#34;
    Play a video for a set duration. Returns when that duration passes.

    ### Arguments:
    - `video` (`str`|`ytdriver.helpers.Video`): Video object or URL to play.
    - `duration` (`int`): How long to play the video.
    
    &#34;&#34;&#34;
    try:
        self.__click_video(video)
        self.__check_video_availability()
        self.__click_play_button()
        self.__handle_ads()
        self.__clear_prompts()
        sleep(duration)
    except WebDriverException as e:
        self.__log(e)</code></pre>
</details>
</dd>
<dt id="ytdriver.YTDriver.YTDriver.save_screenshot"><code class="name flex">
<span>def <span class="ident">save_screenshot</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Save a screenshot of the current browser window.</p>
<h3 id="arguments">Arguments:</h3>
<ul>
<li><code>filename</code>: Filename to save image as.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_screenshot(self, filename):
    &#34;&#34;&#34;
    Save a screenshot of the current browser window.

    ### Arguments:
    - `filename`: Filename to save image as.
    &#34;&#34;&#34;
    return self.driver.save_screenshot(filename)</code></pre>
</details>
</dd>
<dt id="ytdriver.YTDriver.YTDriver.search_videos"><code class="name flex">
<span>def <span class="ident">search_videos</span></span>(<span>self, query, scroll_times=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Search for videos.</p>
<h3 id="arguments">Arguments:</h3>
<ul>
<li><code>query</code> (<code>str</code>): Search query.</li>
</ul>
<h3 id="returns">Returns:</h3>
<ul>
<li>List of videos of type <code><a title="ytdriver.helpers.Video" href="helpers.html#ytdriver.helpers.Video">Video</a></code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_videos(self, query, scroll_times=0):
    &#34;&#34;&#34;
    Search for videos.

    ### Arguments:
    - `query` (`str`): Search query.

    ### Returns:
    - List of videos of type `ytdriver.helpers.Video`.
    
    &#34;&#34;&#34;

    # load video search results
    self.driver.get(&#39;https://www.youtube.com/results?search_query=%s&#39; % query)

    # wait for page to load
    sleep(2)

    # scroll page to load more results
    for _ in range(scroll_times):
        self.driver.find_element(By.TAG_NAME, &#39;body&#39;).send_keys(Keys.PAGE_DOWN)
        sleep(0.2)

    # collect video-like tags from homepage
    videos = self.driver.find_elements(By.XPATH, &#39;//div[@id=&#34;contents&#34;]/ytd-video-renderer&#39;)
    
    # identify actual videos from tags
    results = []
    for video in videos:
        a = video.find_elements(By.TAG_NAME, &#39;a&#39;)[0]
        href = a.get_attribute(&#39;href&#39;)
        if href is not None and href.startswith(&#39;https://www.youtube.com/watch?&#39;):
            results.append(Video(a, href))
    return results</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ytdriver" href="index.html">ytdriver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ytdriver.YTDriver.YTDriver" href="#ytdriver.YTDriver.YTDriver">YTDriver</a></code></h4>
<ul class="two-column">
<li><code><a title="ytdriver.YTDriver.YTDriver.close" href="#ytdriver.YTDriver.YTDriver.close">close</a></code></li>
<li><code><a title="ytdriver.YTDriver.YTDriver.get_homepage" href="#ytdriver.YTDriver.YTDriver.get_homepage">get_homepage</a></code></li>
<li><code><a title="ytdriver.YTDriver.YTDriver.get_recommendations" href="#ytdriver.YTDriver.YTDriver.get_recommendations">get_recommendations</a></code></li>
<li><code><a title="ytdriver.YTDriver.YTDriver.play" href="#ytdriver.YTDriver.YTDriver.play">play</a></code></li>
<li><code><a title="ytdriver.YTDriver.YTDriver.save_screenshot" href="#ytdriver.YTDriver.YTDriver.save_screenshot">save_screenshot</a></code></li>
<li><code><a title="ytdriver.YTDriver.YTDriver.search_videos" href="#ytdriver.YTDriver.YTDriver.search_videos">search_videos</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>